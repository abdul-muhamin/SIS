import { Blob, FetchError, FormData, fetch, jsonl, withRetry, withTimeout, } from '@chatbotkit/fetch';
const fetchPlusPlus = withRetry(withTimeout(fetch));
const standardErrors = {
    413: {
        message: 'Client request is too large to be processed by the web server.',
        code: 'CONTENT_TOO_LARGE',
    },
    default: {
        message: 'There was a generic error',
        code: 'GENERIC_ERROR',
    },
};
export class ResponsePromise {
    constructor(url, request) {
        this.url = url;
        this.request = request;
        this.decoder = new TextDecoder();
        this.fetchPromise = null;
        this.streamPromise = null;
    }
    get [Symbol.toStringTag]() {
        return 'ResponsePromise';
    }
    async getRequest(params) {
        let body;
        const { method, headers, data } = this.request;
        if (data) {
            body = params?.data || data;
        }
        const url = this.url.toString();
        const response = await fetchPlusPlus(url, {
            method: params?.method || method,
            headers: {
                ...headers,
                ...params?.headers,
            },
            body,
            mode: 'cors',
            cache: 'no-cache',
        });
        if (!response.ok) {
            let message;
            let code;
            const buffer = await response.arrayBuffer();
            try {
                const data = JSON.parse(new TextDecoder().decode(buffer));
                message = data.message;
                code = data.code;
            }
            catch (e) {
                const data = standardErrors[response.status] || standardErrors.default;
                message = data.message;
                code = data.code;
            }
            throw new FetchError(message, code, url, this.request, response);
        }
        return response;
    }
    getFetchPromise() {
        if (!this.fetchPromise) {
            this.fetchPromise = this.getRequest();
        }
        return this.fetchPromise;
    }
    getStreamPromise() {
        if (!this.streamPromise) {
            this.streamPromise = this.getRequest({
                headers: { Accept: 'application/jsonl' },
            });
        }
        return this.streamPromise;
    }
    then(onSuccess, onFail) {
        return this.getFetchPromise()
            .then(async (response) => {
            if (response.headers.get('content-type')?.includes('application/json')) {
                return await response.json();
            }
            else {
                return {
                    data: await response.arrayBuffer(),
                };
            }
        })
            .then(onSuccess, onFail);
    }
    catch(fn) {
        return this.getFetchPromise().catch(fn);
    }
    finally(fn) {
        return this.getFetchPromise().finally(fn);
    }
    async *stream() {
        const response = await this.getStreamPromise();
        if (!response.body) {
            return;
        }
        yield* jsonl(response.body);
    }
}
export class ChatBotKitClient {
    constructor(options) {
        this.secret = options.secret;
        this.url = new URL(`https://api.chatbotkit.com`);
        if (options.host) {
            this.url.host = options.host;
        }
        if (options.protocol) {
            this.url.protocol = options.protocol;
        }
        this.endpoints = options.endpoints || {};
        this.runAsUserId = options.runAsUserId;
    }
    clientFetch(path, options) {
        let method = options?.method;
        const url = new URL(this.endpoints[path] || path, this.url);
        if (url.hostname === 'api.chatbotkit.com' &&
            url.pathname.startsWith('/api/')) {
            url.pathname = url.pathname.substring(4);
        }
        if (options?.query) {
            for (const key in options.query) {
                const value = options.query[key];
                if (typeof value === 'object') {
                    for (const subKey in value) {
                        const subValue = value[subKey];
                        url.searchParams.append(`${key}.${subKey}`, subValue);
                    }
                }
                else {
                    url.searchParams.append(key, value);
                }
            }
        }
        const headers = {};
        if (!options?.external) {
            if (this.secret) {
                headers['Authorization'] = `Bearer ${this.secret}`;
            }
            if (this.runAsUserId) {
                headers['X-RunAs-UserId'] = this.runAsUserId;
            }
        }
        let data;
        if (options?.record) {
            method = method || 'POST';
            data = JSON.stringify(options.record);
            headers['Content-Type'] = 'application/json';
        }
        else if (options?.buffer) {
            method = method || 'POST';
            data = options.buffer;
            headers['Content-Type'] = 'application/octet-stream';
        }
        else if (options?.file) {
            method = method || 'POST';
            data = new FormData();
            data.append('file', new Blob([options.file.data], { type: options.file.type }), options.file.name);
        }
        else {
            method = method || 'GET';
        }
        if (options?.headers) {
            Object.assign(headers, options.headers);
        }
        const request = {
            method,
            headers,
            data,
        };
        return new ResponsePromise(url, request);
    }
}
